import sqlite3
#IN ORDER TO CONNECT THE CODE FROM OTHER FILE YOU NEED TO IMPORT THE PY TO THE SQLITE CONNECTION CODE
from Python_SQLite_Tutorial_Employee import Employee

#THIS MEANS TEMPORARY IN-MEMORY SQLITE DATABASE
#IT CREATES DATABASE IN RAM NOT ON DISK
# GOOD FOR TESTING ONLY EVERY FRESH DATABASE
# ':memory:'
# conn = sqlite3.connect(':memory:')

# IF THERE IS NO EMPLOYEE.DB FILE THEN IT CREATES ONE IN THE DIRECTORY
conn = sqlite3.connect('employee.db')

#CURSOR IS NEEDED TO EXECUTE COMMANDS
c = conn.cursor()

emp_1 = Employee('John','Doe',8000)
emp_2 = Employee('Jane','Doe',1000)

# THERE IS TWO WAYS TO USE INSERT INTO
# FIRST IS PLACEHOLDER WITH ? ? ? AND USE PARAMETERS
c.execute("INSERT INTO employees VALUES (?,?,?)", (emp_1.first, emp_1.last, emp_1.pay))
conn.commit()
# SECOND IS USING A DICTIONARY, THIS IS MORE READABLE
c.execute("INSERT INTO employees VALUES (:first,:last,:pay)",
          {'first': emp_2.first, 'last': emp_2.last, 'pay': emp_2.pay})
conn.commit()


#IN THE DOCUMENTATION IT USES DOCSTRING WHICH IS 3 """
#BUT SINGLE OR ONE QUOTE IT IS FINE I THINK

#SO THIS EXECUTE CREATE TABLE CAN ONLY BE RUN ONCE TO CREATE THE TABLE AND ONCE IT IS CREATED, IF YOU TRY TO RUN THIS AGAIN
#IT WILL GIVE YOU ERROR BECAUSE THE TABLE ALREADY EXISTS, AND THERE IS NO NEED TO CREATE A TABLE THAT IS ALREADY THERE
c.execute("""CREATE TABLE employees(
        first text,
        last text,
        pay integer
        )""")

# THIS IS TO ADD A DATA INTO THE DATABASE
# c.execute("INSERT INTO employees VALUES ('Maria','Schafer',70000)")
# conn.commit()

# SELECT STATEMENT TO FIND DATA
c.execute("SELECT * FROM employees WHERE last='Doe'")

# YOU CAN USE PLACEHOLDER AGAIN IN SELECT OR IN DICTIONARY KAHIT ANO GUSTO MO HASHASAHSAHS
#NEEDS FETCH PER SELECT EXECUTE
c.execute("SELECT * FROM employees WHERE last=?", ('Schafer',))
print(c.fetchall())

c.execute("SELECT * FROM employees WHERE last=:last", {"last": "Doe"})
print(c.fetchall())


#RETURNS ONE ROW
# RETURNS ALL ROWS AND IT WILL BE ON A LIST
# c.fetchall()

#WITH FETCHMANY IT NEEDS A SIZE, WHERE IT WILL RETRIEVE HOW MANY ROWS IN THE DATABASE THAT YOU WANT
#IF YOU WANT 5 THEN PUT 5
# c.fetchmany(5)


# THIS COMMITS THE TRANSACTION, MEANING THE EXECUTE
# USES THE CONN NOT THE C FROM THE CURSOR
# conn.commit()


#ALWAYS CLOSE THE CONNECTION

conn.close()

#WITH THE SELECT STATEMENT YOU DONT NEED CONN.COMMIT()
#BUT WITH HE INSERT UPDATE DELETE YOU NEED TO PUT CONN.COMMIT() EVERY EXECUTE THAT YOU DO